diff --git a/BaseClasses.py b/BaseClasses.py
index ca717b60f..5fc5bbf19 100644
--- a/BaseClasses.py
+++ b/BaseClasses.py
@@ -1689,6 +1689,17 @@ class Spoiler:
 
     def create_playthrough(self, create_paths: bool = True) -> None:
         """Destructive to the multiworld while it is run, damage gets repaired afterwards."""
+
+        # Check if sphere logging is enabled and use enhanced version if so
+        try:
+            from settings import get_settings
+            settings = get_settings()
+            if settings.general_options.save_sphere_log:
+                from exporter.sphere_logger import create_playthrough_with_logging
+                return create_playthrough_with_logging(self, create_paths)
+        except (ImportError, AttributeError):
+            pass  # Fall through to original implementation
+
         from itertools import chain
         # get locations containing progress items
         multiworld = self.multiworld
diff --git a/Main.py b/Main.py
index bc2787579..d0e52b5cc 100644
--- a/Main.py
+++ b/Main.py
@@ -19,6 +19,7 @@ from Utils import __version__, output_path, restricted_dumps, version_tuple
 from settings import get_settings
 from worlds import AutoWorld
 from worlds.generic.Rules import exclusion_rules, locality_rules
+from exporter import export_game_rules
 
 __all__ = ["main"]
 
@@ -34,6 +35,9 @@ def main(args, seed=None, baked_server_options: dict[str, object] | None = None)
     start = time.perf_counter()
     # initialize the multiworld
     multiworld = MultiWorld(args.multi)
+    
+    # Set output directory for sphere logging
+    multiworld.temp_dir_for_spheres_log = args.outputpath
 
     logger = logging.getLogger()
     multiworld.set_seed(seed, args.race, str(args.outputname) if args.outputname else None)
@@ -197,6 +201,18 @@ def main(args, seed=None, baked_server_options: dict[str, object] | None = None)
 
     AutoWorld.call_all(multiworld, 'post_fill')
 
+    # Apply vanilla item placement overrides if requested
+    import os as os_module
+    if os_module.environ.get('VANILLA_PLACEMENT') == '1':
+        print("\n!!! Applying Vanilla Item Placement Overrides !!!")
+        from worlds.alttp.VanillaPlacement import overwrite_with_vanilla_items
+        for world in multiworld.get_game_worlds("A Link to the Past"):
+            overwrite_with_vanilla_items(world)
+        # Mark that we're using vanilla placement for later checks
+        multiworld.vanilla_placement = True
+    else:
+        multiworld.vanilla_placement = False
+
     if multiworld.players > 1 and not args.skip_prog_balancing:
         balance_multiworld_progression(multiworld)
     else:
@@ -226,7 +242,12 @@ def main(args, seed=None, baked_server_options: dict[str, object] | None = None)
         output_players = [player for player in multiworld.player_ids if AutoWorld.World.generate_output.__code__
                           is not multiworld.worlds[player].generate_output.__code__]
         with concurrent.futures.ThreadPoolExecutor(len(output_players) + 2) as pool:
-            check_accessibility_task = pool.submit(multiworld.fulfills_accessibility)
+            # Skip accessibility check if using vanilla placement
+            if getattr(multiworld, 'vanilla_placement', False):
+                print("Skipping accessibility check for vanilla placement")
+                check_accessibility_task = pool.submit(lambda: True)  # Always return True
+            else:
+                check_accessibility_task = pool.submit(multiworld.fulfills_accessibility)
 
             output_file_futures = [pool.submit(AutoWorld.call_stage, multiworld, "generate_output", temp_dir)]
             for player in output_players:
@@ -364,6 +385,10 @@ def main(args, seed=None, baked_server_options: dict[str, object] | None = None)
                     logger.info(f'Generating output files ({i}/{len(output_file_futures)}).')
                 future.result()
 
+        # Make temp_dir available for spheres_log.jsonl in Spoiler.create_playthrough
+        if hasattr(multiworld, 'spoiler'): # Ensure spoiler object exists
+            multiworld.temp_dir_for_spheres_log = temp_dir
+
         if args.spoiler > 1:
             logger.info('Calculating playthrough.')
             multiworld.spoiler.create_playthrough(create_paths=args.spoiler > 2)
@@ -371,6 +396,11 @@ def main(args, seed=None, baked_server_options: dict[str, object] | None = None)
         if args.spoiler:
             multiworld.spoiler.to_file(os.path.join(temp_dir, '%s_Spoiler.txt' % outfilebase))
 
+        # New: export the rules data to a json file
+        settings = get_settings()
+        if settings.general_options.save_rules_json:
+            export_game_rules(multiworld, temp_dir, outfilebase, settings.general_options.update_frontend_presets, settings.general_options.skip_preset_copy_if_rules_identical)
+
         zipfilename = output_path(f"AP_{multiworld.seed_name}.zip")
         logger.info(f"Creating final archive at {zipfilename}")
         with zipfile.ZipFile(zipfilename, mode="w", compression=zipfile.ZIP_DEFLATED,
diff --git a/settings.py b/settings.py
index 48bc57f04..25d4145da 100644
--- a/settings.py
+++ b/settings.py
@@ -23,6 +23,7 @@ __all__ = [
 ]
 
 no_gui = False
+skip_required_files = False
 skip_autosave = False
 _world_settings_name_cache: dict[str, str] = {}  # TODO: cache on disk and update when worlds change
 _world_settings_name_cache_updated = False
@@ -89,6 +90,12 @@ class Group:
             if attr.required and not attr.exists() and not super().__getattribute__("_has_attr"):
                 # if a file is required, and the one from settings does not exist, ask the user to provide it
                 # unless we are dumping the settings, because that would ask for each entry
+                # or skip_required_files is True
+                if skip_required_files:
+                    import warnings
+                    warnings.warn(f"{attr} does not exist, but {self.__class__.__name__}.{item} is required. "
+                                  f"Continuing anyway as skip_required_files is set.")
+                    return attr
                 with _lock:  # lock to avoid opening multiple
                     new = None if no_gui else attr.browse()
                     if new is None:
@@ -518,6 +525,15 @@ class GeneralOptions(Group):
         # created on demand, so marked as optional
 
     output_path: OutputPath = OutputPath("output")
+    skip_required_files: bool = False
+    save_rules_json: bool = False
+    skip_preset_copy_if_rules_identical: bool = False
+    save_sphere_log: bool = False
+    verbose_sphere_log: bool = False
+    extend_sphere_log_to_all_locations: bool = False
+    log_fractional_sphere_details: bool = True
+    log_integer_sphere_details: bool = False
+    update_frontend_presets: bool = False
 
 
 class ServerOptions(Group):
@@ -888,4 +904,9 @@ def get_settings() -> Settings:
                 res = Settings(None)
                 res.save(user_path(filenames[1]))
             setattr(get_settings, "_cache", res)
+
+            # Update the global variable after loading/creating settings
+            global skip_required_files
+            skip_required_files = res.general_options.skip_required_files
+            
         return res
