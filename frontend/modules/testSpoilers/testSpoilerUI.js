/**
 * Test Spoilers Module
 *
 * Provides UI and logic for testing game logic against spoiler logs generated by Archipelago.
 * Allows step-by-step or full test execution to verify location accessibility calculations
 * match the game's actual randomization results.
 *
 * @module testSpoilers
 */

import { stateManagerProxySingleton as stateManager } from '../stateManager/index.js';
import eventBus from '../../app/core/eventBus.js';
import { evaluateRule } from '../shared/ruleEngine.js';
import { createStateSnapshotInterface } from '../shared/stateInterface.js';
import { createRegionLink } from '../commonUI/index.js';
import TestSpoilerRuleEvaluator from './testSpoilerRuleEvaluator.js';
import { FileLoader } from './fileLoader.js';
import { ComparisonEngine } from './comparisonEngine.js';
import { AnalysisReporter } from './analysisReporter.js';
import { EventProcessor } from './eventProcessor.js';
import { TestOrchestrator } from './testOrchestrator.js';
import { createUniversalLogger } from '../../app/core/universalLogger.js';

const logger = createUniversalLogger('testSpoilerUI');

// Helper function for logging with fallback
function log(level, message, ...data) {
  if (
    typeof window !== 'undefined' &&
    window.logger &&
    typeof window.logger[level] === 'function'
  ) {
    window.logger[level]('testSpoilerUI', message, ...data);
  } else {
    const consoleMethod =
      console[level === 'info' ? 'log' : level] || console.log;
    consoleMethod(`[testSpoilerUI] ${message}`, ...data);
  }
}

/**
 * Main UI controller for the Test Spoilers panel.
 *
 * Coordinates the UI, file loading, comparison logic, and test orchestration
 * to verify that state manager's accessibility calculations match spoiler log data.
 *
 * @class TestSpoilerUI
 * @memberof module:testSpoilers
 */
export class TestSpoilerUI {
  constructor(container, componentState) {
    this.container = container;
    this.componentState = componentState;

    this.initialized = false;
    this.testSpoilersContainer = null;
    this.currentSpoilerFile = null;
    this.currentSpoilerLogPath = null;
    this.logContainer = null;
    this.controlsContainer = null;
    this.abortController = null;
    this.spoilersPanelContainer = null;
    this.viewChangeSubscription = null;
    this.eventBus = eventBus;
    this.rootElement = null;
    this.activeRulesetName = null;
    this.gameName = null;
    this.playerId = null;
    this.log('debug', `[Constructor] Initial playerId: ${this.playerId}`);
    this.isLoadingLogPath = null;

    // State for stepping through tests
    this.spoilerLogData = null;
    this.currentLogIndex = 0;
    this.testStateInitialized = false;
    this.initialAutoLoadAttempted = false;
    this.eventProcessingDelayMs = 0;
    this.stopOnFirstError = true;
    this.currentMismatchDetailsArray = [];
    this.ruleEvaluator = new TestSpoilerRuleEvaluator((level, message, ...data) => this.log(level, message, ...data));

    // Initialize module dependencies
    this.fileLoader = new FileLoader();
    this.comparisonEngine = new ComparisonEngine(
      stateManager,
      (type, message, ...data) => this.log(type, message, ...data)
    );
    this.analysisReporter = new AnalysisReporter(
      this.ruleEvaluator,
      (type, message, ...data) => this.log(type, message, ...data)
    );
    this.eventProcessor = new EventProcessor(
      this.comparisonEngine,
      this.analysisReporter,
      this.eventBus,
      (type, message, ...data) => this.log(type, message, ...data)
    );

    // Create UI callbacks object for orchestrator
    const uiCallbacks = {
      clearContainer: () => {
        this.testSpoilersContainer.innerHTML = '';
      },
      ensureLogContainerReady: () => this.ensureLogContainerReady(),
      clearLog: () => {
        if (this.logContainer) {
          this.logContainer.innerHTML = '';
        }
      },
      log: (type, message, ...data) => this.log(type, message, ...data),
      renderManualFileSelectionView: (message) => this.renderManualFileSelectionView(message),
      renderResultsControls: () => this.renderResultsControls(),
      setButtonsEnabled: (enabled) => {
        const runButton = document.getElementById('run-full-spoiler-test');
        const stepButton = document.getElementById('step-spoiler-test');
        if (runButton) runButton.disabled = !enabled;
        if (stepButton) stepButton.disabled = !enabled;
      },
      updateStepInfo: (currentIndex, totalEvents, logPath) => {
        const stepButton = this.controlsContainer?.querySelector('#step-spoiler-test');
        if (stepButton) {
          stepButton.textContent = `Step Test (Step ${currentIndex} / ${totalEvents})`;
        }
        const testNameElement = this.controlsContainer?.querySelector('#spoiler-test-name');
        if (testNameElement) {
          // Fallback chain: logPath → currentSpoilerFile.name → 'Unknown Log'
          testNameElement.textContent = `Testing: ${logPath || (this.currentSpoilerFile ? this.currentSpoilerFile.name : 'Unknown Log')
            }`;
        }
      },
      getLogEntries: () => {
        if (this.logContainer) {
          const logEntries = this.logContainer.querySelectorAll('.log-entry');
          return Array.from(logEntries).map(entry => entry.textContent);
        }
        return [];
      }
    };

    // State configuration object for orchestrator
    const self = this;
    const stateConfig = {
      get stopOnFirstError() { return self.stopOnFirstError; },
      get eventProcessingDelayMs() { return self.eventProcessingDelayMs; }
    };

    this.testOrchestrator = new TestOrchestrator(
      this.eventProcessor,
      uiCallbacks,
      stateConfig
    );

    // Create and append root element immediately
    this.getRootElement(); // This creates this.rootElement and sets this.testSpoilersContainer
    if (this.rootElement) {
      this.container.element.appendChild(this.rootElement);
    } else {
      log('error', '[TestSpoilerUI] Root element not created in constructor!');
    }

    // Defer the rest of initialization
    const readyHandler = (eventPayload) => {
      log(
        'info',
        '[TestSpoilerUI] Received app:readyForUiDataLoad. Initializing spoilers.'
      );
      this.initialize(); // This will call the modified initialize method

      eventBus.unsubscribe('app:readyForUiDataLoad', readyHandler);
    };
    eventBus.subscribe('app:readyForUiDataLoad', readyHandler, 'testSpoilers');

    this.container.on('destroy', () => {
      this.dispose();
    });
  }

  getRootElement() {
    if (!this.rootElement) {
      this.rootElement = document.createElement('div');
      this.rootElement.className = 'test-spoilers-module-root';
      this.testSpoilersContainer = document.createElement('div');
      this.testSpoilersContainer.className = 'test-spoilers-container';
      this.rootElement.appendChild(this.testSpoilersContainer);

      // Add styles for the module
      const style = document.createElement('style');
      style.textContent = `
        .test-spoilers-module-root {
          display: flex;
          flex-direction: column;
          height: 100%;
          background-color: #2c2c2c; /* Dark theme background */
          color: #e0e0e0; /* Light text for dark theme */
        }
        .test-spoilers-container {
          flex-grow: 1;
          display: flex;
          flex-direction: column;
          padding: 10px;
          overflow: hidden;
        }
        #spoiler-controls-container {
            margin-bottom: 10px;
        }
        #spoiler-log-output {
          border: 1px solid #555; /* Darker border */
          padding: 8px;
          min-height: 0; /* Helps flexbox correctly calculate overflow */
          overflow-y: auto;
          background-color: #333; /* Dark background for log */
          color: #ccc; /* Lighter text for log */
          flex-grow: 1;
          flex-basis: 0;
          margin-top: 10px;
          font-family: monospace;
        }
        .spoiler-test-controls button,
        .spoiler-file-select-controls button,
        .spoiler-file-select-controls input[type="file"]::file-selector-button {
            margin-right: 5px;
            padding: 5px 10px;
            background-color: #555;
            color: #eee;
            border: 1px solid #777;
            border-radius: 3px;
            cursor: pointer;
        }
        .spoiler-test-controls button:hover,
        .spoiler-file-select-controls button:hover,
        .spoiler-file-select-controls input[type="file"]::file-selector-button:hover {
            background-color: #666;
        }
        .spoiler-file-select-controls p {
          margin-bottom: 5px;
          color: #d0d0d0; /* Ensure paragraph text is visible */
        }
        .spoiler-file-select-controls input[type="file"] {
          color-scheme: dark; /* Hint for browser to use dark mode for file input if supported */
          margin-bottom: 5px;
        }
        /* Log entry styling (copied and adapted from previous manual file selection style) */
        .log-entry { margin-bottom: 0.25rem; border-bottom: 1px solid #444; padding-bottom: 0.25rem; }
        .log-entry:last-child { border-bottom: none; }
        .log-error { color: #ff6b6b; font-weight: bold; } /* Light red for errors */
        .log-success { color: #76ff7e; font-weight: bold; } /* Light green for success */
        .log-info { color: #aaa; }
        .log-warn { color: #ffdd57; } /* Light yellow for warnings */
        .log-step { color: #ffc107; }
        .log-state { color: #5cacee; } /* Light blue for state */
        .log-mismatch { background-color: rgba(255, 107, 107, 0.2); padding: 2px 4px; border-radius: 3px; }
      `;
      this.rootElement.appendChild(style);
    }
    return this.rootElement;
  }

  async initialize() {
    if (this.initialized) return;
    this.spoilersPanelContainer = this.container.element; // Get the actual DOM element from GL container
    this.spoilersPanelContainer.appendChild(this.getRootElement());

    this.log('info', 'Test Spoiler UI Initializing...');

    // Clear container and set up basic structure initially
    this.testSpoilersContainer.innerHTML = '';
    this.ensureLogContainerReady();

    // Check for existing ruleset immediately on initialization
    try {
      const currentRulesetSource = stateManager.getRawJsonDataSource();
      if (currentRulesetSource && !this.activeRulesetName) {
        this.activeRulesetName = currentRulesetSource;
        this.log('info', `Found existing ruleset on initialization: ${this.activeRulesetName}`);
      }
    } catch (error) {
      this.log('debug', `Could not get current ruleset source: ${error.message}`);
    }

    // Always render manual file selection view on initialization
    this.renderManualFileSelectionView(
      'Select a spoiler log file or load the suggested one if available.'
    );
    this.log(
      'info',
      'Test Spoilers panel ready. Waiting for user to load a spoiler log.'
    );

    if (this.rulesLoadedUnsub) this.rulesLoadedUnsub();
    this.rulesLoadedUnsub = this.eventBus.subscribe(
      'stateManager:rulesLoaded',
      async (eventData) => {
        this.log(
          'info',
          `[TestSpoilerUI] Received stateManager:rulesLoaded (Subscriber)`,
          eventData
        );
        if (eventData && eventData.source) {
          const newRulesetName = eventData.source;
          this.activeRulesetName = newRulesetName; // Update active ruleset name
          this.playerId = eventData.playerId;
          this.log(
            'info',
            `Active ruleset updated to: ${newRulesetName}, Player ID: ${this.playerId}`
          );
          if (!this.spoilerLogData) {
            this.renderManualFileSelectionView(
              `Ruleset changed to ${newRulesetName}. Suggested log updated.`
            );
          } else {
            this.log(
              'info',
              `Ruleset changed to ${newRulesetName}, but a log is already loaded. Suggested log path may have updated.`
            );
            if (
              this.controlsContainer &&
              !this.controlsContainer.querySelector('#run-full-spoiler-test')
            ) {
              this.renderManualFileSelectionView(
                `Ruleset changed to ${newRulesetName}. Suggested log updated.`
              );
            }
          }
        }
      }
      , 'testSpoilers');

    if (this.rawJsonDataUnsub) this.rawJsonDataUnsub();
    this.rawJsonDataUnsub = this.eventBus.subscribe(
      'stateManager:rawJsonDataLoaded',
      (data) => {
        if (data && data.source && !this.activeRulesetName) {
          this.activeRulesetName = data.source;
          log(
            'info',
            `[TestSpoilerUI] Active ruleset name set from rawJsonDataLoaded: ${this.activeRulesetName}`
          );
          if (!this.spoilerLogData) {
            this.renderManualFileSelectionView(
              `Initial ruleset ${this.activeRulesetName} detected. Suggested log updated.`
            );
          }
        }
      }
      , 'testSpoilers');

    this.initialized = true;
    this.log(
      'info',
      'Test Spoiler UI Initialization complete. Manual load required.'
    );
  }

  async attemptAutoLoadSpoilerLog(rulesetPath) {
    if (!this.testSpoilersContainer) return;

    // Handle no ruleset path case
    if (!rulesetPath) {
      logger.warn('Cannot attempt auto-load: rulesetPath is undefined or invalid');
      this.testSpoilersContainer.innerHTML = '';
      this.ensureLogContainerReady();
      this.renderManualFileSelectionView(
        'Cannot determine ruleset for auto-load. Please select a log file.'
      );
      return;
    }

    // Delegate to FileLoader module
    const result = await this.fileLoader.attemptAutoLoad(
      rulesetPath,
      this.currentSpoilerLogPath,
      this.spoilerLogData,
      this.isLoadingLogPath
    );

    // Handle already loading case
    if (result.error === 'Already loading this log path.') {
      return;
    }

    // Handle already loaded case
    if (result.alreadyLoaded) {
      logger.info(
        `Spoiler log for ${result.logPath} is already loaded and processed. Refreshing UI.`
      );
      this.testSpoilersContainer.innerHTML = '';
      this.ensureLogContainerReady();
      this.renderResultsControls();
      logger.info(`Displaying already loaded test: ${this.currentSpoilerLogPath}`);
      this.updateStepInfo();
      return;
    }

    // Set loading flag
    this.isLoadingLogPath = result.logPath;

    try {
      // Handle failure case
      if (!result.success) {
        logger.warn(result.error);
        if (this.initialAutoLoadAttempted) {
          this.renderManualFileSelectionView(
            `Auto-load failed: ${result.error}. Please select a file manually.`
          );
        }
        this.spoilerLogData = null;
        this.currentSpoilerLogPath = null;
        return;
      }

      // Handle success case
      this.clearTestState(); // Clear previous test state
      this.spoilerLogData = result.logData;
      this.currentSpoilerLogPath = result.logPath;
      await this.prepareSpoilerTest(true);
    } catch (error) {
      logger.warn(
        `Failed to process spoiler log from ${result.logPath}. Error: ${error.message}`
      );
      this.spoilerLogData = null;
      this.currentSpoilerLogPath = null;
      this.testSpoilersContainer.innerHTML = '';
      this.ensureLogContainerReady();
      this.renderManualFileSelectionView(
        `Auto-load failed for ${result.logPath}. ${error.message}. Please select a spoiler log file.`
      );
    } finally {
      this.isLoadingLogPath = null; // Clear loading flag
    }
  }

  extractFilenameBase(filePathOrName) {
    // Delegate to FileLoader module
    return this.fileLoader.extractFilenameBase(filePathOrName);
  }

  renderManualFileSelectionView(
    message = 'Select a Spoiler Log File (.jsonl)'
  ) {
    this.testSpoilersContainer.innerHTML = ''; // Clear previous content
    this.ensureLogContainerReady(); // Setup basic structure including log container

    this.log('info', message); // Log the message to the log area

    const fileSelectionContainer = document.createElement('div');
    fileSelectionContainer.className = 'spoiler-file-select-controls';

    // Display suggested filename and add a button to load it
    const suggestedLogInfoContainer = document.createElement('div');
    suggestedLogInfoContainer.className = 'suggested-log-info';
    let suggestedLogName = 'No active ruleset detected for suggestion.';
    let canLoadSuggested = false;

    if (this.activeRulesetName) {
      const baseName = this.extractFilenameBase(this.activeRulesetName);
      suggestedLogName = `${baseName}_spheres_log.jsonl`;
      canLoadSuggested = true;
      suggestedLogInfoContainer.innerHTML = `
        <p>Current ruleset: <strong>${this.escapeHtml(
        this.activeRulesetName
      )}</strong></p>
        <p>Suggested log file: <strong>${this.escapeHtml(
        suggestedLogName
      )}</strong></p>
      `;
      const loadSuggestedButton = document.createElement('button');
      loadSuggestedButton.textContent = 'Load Suggested Log';
      loadSuggestedButton.id = 'load-suggested-spoiler-log';
      loadSuggestedButton.onclick = async () => {
        if (this.activeRulesetName) {
          this.log(
            'info',
            `User initiated load for suggested log derived from: ${this.activeRulesetName}`
          );
          // attemptAutoLoadSpoilerLog derives the path from activeRulesetName
          await this.attemptAutoLoadSpoilerLog(this.activeRulesetName);
        } else {
          this.log(
            'warn',
            'Cannot load suggested log: No active ruleset name available.'
          );
        }
      };
      suggestedLogInfoContainer.appendChild(loadSuggestedButton);
    } else {
      suggestedLogInfoContainer.innerHTML = `<p>${this.escapeHtml(
        suggestedLogName
      )}</p>`;
    }
    fileSelectionContainer.appendChild(suggestedLogInfoContainer);

    const separator = document.createElement('hr');
    fileSelectionContainer.appendChild(separator);

    const manualLoadMessageElement = document.createElement('p');
    manualLoadMessageElement.textContent =
      'Or, select a local spoiler log file (.jsonl):';
    fileSelectionContainer.appendChild(manualLoadMessageElement);

    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.id = 'spoiler-log-file-input';
    fileInput.accept = '.jsonl';

    const loadButton = document.createElement('button');
    loadButton.textContent = 'Load Selected Local Log';
    loadButton.onclick = async () => {
      const file = fileInput.files[0];
      if (file) {
        this.clearTestState();
        this.currentSpoilerFile = file;
        this.currentSpoilerLogPath = file.name;
        this.log('info', `Loading selected file: ${file.name}`);
        const success = await this.readSelectedLogFile(file, null);
        if (success) {
          await this.prepareSpoilerTest(false);
        } else {
          this.renderManualFileSelectionView(
            `Failed to load or parse: ${file.name}. Please try again.`
          );
        }
      } else {
        this.log('warn', 'No file selected.');
      }
    };

    fileSelectionContainer.appendChild(fileInput);
    fileSelectionContainer.appendChild(loadButton);

    // Append the file selection controls to the controls container created by ensureLogContainerReady
    this.controlsContainer.innerHTML = ''; // Clear any previous controls
    this.controlsContainer.appendChild(fileSelectionContainer);
  }

  renderResultsControls() {
    // this.testSpoilersContainer.innerHTML = ''; // prepareSpoilerTest will clear the main container

    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'spoiler-test-controls'; // Use a class for styling

    const changeFileButton = document.createElement('button');
    changeFileButton.textContent = '← Change Log File';
    changeFileButton.onclick = () => {
      if (this.abortController) {
        this.abortController.abort(); // Cancel any ongoing test step
      }
      this.clearTestState();
      this.currentSpoilerFile = null;
      this.currentSpoilerLogPath = null; // Clear the path
      this.renderManualFileSelectionView();
    };

    const testNameElement = document.createElement('span');
    testNameElement.id = 'spoiler-test-name';
    testNameElement.style.marginRight = '10px';
    testNameElement.textContent = `Testing: ${this.currentSpoilerLogPath || 'Unknown Log'
      }`;

    const runFullButton = document.createElement('button');
    runFullButton.id = 'run-full-spoiler-test';
    runFullButton.textContent = 'Run Full Test';
    runFullButton.onclick = () => this.runFullSpoilerTest();

    const stepButton = document.createElement('button');
    stepButton.id = 'step-spoiler-test';
    stepButton.textContent = `Step Test (Step ${this.currentLogIndex} / ${this.spoilerLogData ? this.spoilerLogData.length : 0
      })`;
    stepButton.onclick = () => this.stepSpoilerTest();

    // Checkbox for "Stop on first error"
    const stopOnErrorContainer = document.createElement('div');
    stopOnErrorContainer.style.display = 'inline-block';
    stopOnErrorContainer.style.marginLeft = '15px';

    const stopOnErrorCheckbox = document.createElement('input');
    stopOnErrorCheckbox.type = 'checkbox';
    stopOnErrorCheckbox.id = 'stop-on-first-error-checkbox';
    stopOnErrorCheckbox.checked = this.stopOnFirstError;
    stopOnErrorCheckbox.onchange = (event) => {
      this.stopOnFirstError = event.target.checked;
      this.log(
        'info',
        `"Stop on first error" is now ${this.stopOnFirstError ? 'enabled' : 'disabled'
        }.`
      );
    };

    const stopOnErrorLabel = document.createElement('label');
    stopOnErrorLabel.htmlFor = 'stop-on-first-error-checkbox';
    stopOnErrorLabel.textContent = 'Stop on first error';
    stopOnErrorLabel.style.marginLeft = '4px';

    stopOnErrorContainer.appendChild(stopOnErrorCheckbox);
    stopOnErrorContainer.appendChild(stopOnErrorLabel);

    // Checkbox for auto-collect events
    const autoCollectCheckbox = document.createElement('input');
    autoCollectCheckbox.type = 'checkbox';
    autoCollectCheckbox.id = 'auto-collect-events-checkbox';
    autoCollectCheckbox.checked = false;
    autoCollectCheckbox.style.marginLeft = '10px';
    autoCollectCheckbox.onchange = async (event) => {
      const isEnabled = event.target.checked;
      try {
        await stateManager.setAutoCollectEventsConfig(isEnabled);
        this.log('info', `Auto-collect events manually set to: ${isEnabled}`);
      } catch (error) {
        this.log('error', 'Failed to set auto-collect events config:', error);
        event.target.checked = !isEnabled;
      }
    };

    const autoCollectLabel = document.createElement('label');
    autoCollectLabel.htmlFor = 'auto-collect-events-checkbox';
    autoCollectLabel.textContent = 'Auto-collect Events';
    autoCollectLabel.style.marginLeft = '2px';

    controlsDiv.appendChild(changeFileButton);
    controlsDiv.appendChild(testNameElement);
    controlsDiv.appendChild(runFullButton);
    controlsDiv.appendChild(stepButton);
    controlsDiv.appendChild(stopOnErrorContainer);
    controlsDiv.appendChild(autoCollectCheckbox);
    controlsDiv.appendChild(autoCollectLabel);

    this.controlsContainer.innerHTML = ''; // Clear previous controls
    this.controlsContainer.appendChild(controlsDiv);
  }

  async prepareSpoilerTest(isAutoLoad = false) {
    const prepareSuccess = await this.testOrchestrator.prepareSpoilerTest(
      this.spoilerLogData,
      this.playerId,
      this.currentSpoilerLogPath,
      isAutoLoad
    );
    this._syncStateFromOrchestrator();
    return prepareSuccess;
  }

  /**
   * Synchronizes UI state from orchestrator and event processor
   * Called after orchestrator operations to maintain state consistency
   * @private
   */
  _syncStateFromOrchestrator() {
    // Sync progress and abort controller from orchestrator
    const progress = this.testOrchestrator.getProgress();
    this.currentLogIndex = progress.currentIndex;
    this.testStateInitialized = progress.initialized;
    this.abortController = this.testOrchestrator.abortController;

    // Sync mismatch details from event processor
    this.currentMismatchDetailsArray = this.eventProcessor.getMismatchDetailsArray();
  }

  async runFullSpoilerTest() {
    await this.testOrchestrator.runFullSpoilerTest(
      this.spoilerLogData,
      this.playerId,
      this.currentSpoilerLogPath
    );
    this._syncStateFromOrchestrator();
  }

  async stepSpoilerTest() {
    await this.testOrchestrator.stepSpoilerTest(
      this.spoilerLogData,
      this.playerId,
      this.currentSpoilerLogPath
    );
    this._syncStateFromOrchestrator();
  }

  updateStepInfo() {
    // Delegate to TestOrchestrator module via uiCallbacks
    this.testOrchestrator.updateStepInfo(
      this.spoilerLogData,
      this.currentSpoilerLogPath
    );
  }


  log(type, message, ...additionalData) {
    if (this.logContainer) {
      const entry = document.createElement('div');
      entry.classList.add('log-entry', `log-${type}`);
      const textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

      // Check for location and region lists to make them clickable
      const prefixLocationMismatch =
        ' > Locations accessible in LOG but NOT in STATE (or checked): ';
      const prefixLocationExtra =
        ' > Locations accessible in STATE (and unchecked) but NOT in LOG: ';
      const prefixRegionMismatch =
        ' > Regions accessible in LOG but NOT in STATE: ';
      const prefixRegionExtra =
        ' > Regions accessible in STATE but NOT in LOG: ';
      let isSpecialList = false;

      if (message.startsWith(prefixLocationMismatch)) {
        isSpecialList = true;
        entry.appendChild(
          document.createTextNode(
            `[${new Date().toLocaleTimeString()}]` + prefixLocationMismatch
          )
        );
        const locations = message.substring(prefixLocationMismatch.length).split(', ');
        this._addLocationLinksToElement(entry, locations);
      } else if (message.startsWith(prefixLocationExtra)) {
        isSpecialList = true;
        entry.appendChild(
          document.createTextNode(
            `[${new Date().toLocaleTimeString()}]` + prefixLocationExtra
          )
        );
        const locations = message.substring(prefixLocationExtra.length).split(', ');
        this._addLocationLinksToElement(entry, locations);
      } else if (message.startsWith(prefixRegionMismatch)) {
        isSpecialList = true;
        entry.appendChild(
          document.createTextNode(
            `[${new Date().toLocaleTimeString()}]` + prefixRegionMismatch
          )
        );
        const regions = message.substring(prefixRegionMismatch.length).split(', ');
        this._addRegionLinksToElement(entry, regions);
      } else if (message.startsWith(prefixRegionExtra)) {
        isSpecialList = true;
        entry.appendChild(
          document.createTextNode(
            `[${new Date().toLocaleTimeString()}]` + prefixRegionExtra
          )
        );
        const regions = message.substring(prefixRegionExtra.length).split(', ');
        this._addRegionLinksToElement(entry, regions);
      }

      if (!isSpecialList) {
        entry.textContent = textContent;
      }
      this.logContainer.appendChild(entry);
      this.logContainer.scrollTop = this.logContainer.scrollHeight;
    }

    // Log to browser console via centralized logger
    let logLevel = type;
    if (type === 'step' || type === 'mismatch' || type === 'state') {
      logLevel = 'info';
    } else if (type === 'success') {
      logLevel = 'info';
    } else if (type === 'log') {
      logLevel = 'info';
    }
    if (!['error', 'warn', 'info', 'debug'].includes(logLevel)) {
      logLevel = 'info';
    }
    if (
      typeof window !== 'undefined' &&
      window.logger &&
      typeof window.logger[logLevel] === 'function'
    ) {
      window.logger[logLevel]('testSpoilerUI', message, ...additionalData);
    } else {
      const consoleMethod = console[logLevel] || console.log;
      consoleMethod(
        `[testSpoilerUI] ${message}`,
        ...additionalData
      );
    }
  }

  _addLocationLinksToElement(element, locationNames) {
    locationNames.forEach((locName, index) => {
      const staticData = stateManager.getStaticData();
      const locDef = staticData?.locations?.get(locName.trim());
      const regionName = locDef?.region || locDef?.parent_region;

      if (regionName) {
        const snapshot = stateManager.getLatestStateSnapshot();
        const link = createRegionLink(regionName, false, snapshot);
        link.textContent = this.escapeHtml(locName.trim());
        link.title = `Navigate to region: ${this.escapeHtml(regionName)}`;
        element.appendChild(link);
      } else {
        element.appendChild(
          document.createTextNode(this.escapeHtml(locName.trim()))
        );
      }

      if (index < locationNames.length - 1) {
        element.appendChild(document.createTextNode(', '));
      }
    });
  }

  _addRegionLinksToElement(element, regionNames) {
    regionNames.forEach((regionName, index) => {
      const staticData = stateManager.getStaticData();
      const regionDef = staticData?.regions?.get(regionName.trim());

      if (regionDef) {
        const snapshot = stateManager.getLatestStateSnapshot();
        const link = createRegionLink(regionName.trim(), false, snapshot);
        link.textContent = this.escapeHtml(regionName.trim());
        link.title = `Navigate to region: ${this.escapeHtml(regionName.trim())}`;
        element.appendChild(link);
      } else {
        element.appendChild(
          document.createTextNode(this.escapeHtml(regionName.trim()))
        );
      }

      if (index < regionNames.length - 1) {
        element.appendChild(document.createTextNode(', '));
      }
    });
  }

  escapeHtml(unsafe) {
    if (unsafe === null || unsafe === undefined) return '';
    return unsafe
      .toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  clearDisplay() {
    this.clearTestState();
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
  }

  clearTestState() {
    this.log('info', 'Clearing current spoiler test state.');
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.spoilerLogData = null;
    this.currentLogIndex = 0;
    this.testStateInitialized = false;

    // Re-enable auto-collect events (fire-and-forget)
    stateManager
      .setAutoCollectEventsConfig(true)
      .then(() =>
        this.log(
          'info',
          '[TestSpoilerUI] Auto-collect events re-enabled via clearTestState.'
        )
      )
      .catch((error) =>
        this.log(
          'error',
          '[TestSpoilerUI] Failed to re-enable auto-collect events via clearTestState:',
          error
        )
      );
  }

  dispose() {
    log('info', '[TestSpoilerUI] Disposing...');
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    if (this.viewChangeSubscription) {
      this.viewChangeSubscription();
      this.viewChangeSubscription = null;
      log('info', '[TestSpoilerUI] Unsubscribed from ui:fileViewChanged.');
    }
    // Ensure auto-collect events is re-enabled on dispose (fire-and-forget)
    stateManager
      .setAutoCollectEventsConfig(true)
      .then(() =>
        this.log(
          'info',
          '[TestSpoilerUI] Auto-collect events re-enabled via dispose.'
        )
      )
      .catch((error) =>
        this.log(
          'error',
          '[TestSpoilerUI] Failed to re-enable auto-collect events via dispose:',
          error
        )
      );

    this.updateStepInfo();
  }

  async readSelectedLogFile(file, signal) {
    // Delegate to FileLoader module
    try {
      const result = await this.fileLoader.readFile(file, signal);

      if (!result.success) {
        logger.warn(`No valid log events found in file: ${file.name}`);
        return false; // Indicate failure to caller
      }

      // Store results
      this.spoilerLogData = result.logData;
      this.currentSpoilerFile = file;
      this.currentSpoilerLogPath = file.name;

      return true; // Indicate success to caller
    } catch (error) {
      if (error.name === 'AbortError') {
        logger.info('File reading aborted');
      } else {
        logger.error(`Error reading file ${file.name}: ${error.message}`);
      }
      throw error; // Re-throw so caller can handle
    }
  }

  ensureLogContainerReady() {
    // Ensures the basic DOM structure for controls and log output exists.

    if (!this.testSpoilersContainer) {
      console.error(
        '[TestSpoilerUI ensureLogContainerReady] this.testSpoilersContainer is null. Cannot proceed.'
      );
      // Attempt to recover or log verbosely
      if (this.rootElement) {
        let foundContainer = this.rootElement.querySelector(
          '.test-spoilers-container'
        );
        if (foundContainer) {
          this.testSpoilersContainer = foundContainer;
          console.warn(
            '[TestSpoilerUI ensureLogContainerReady] Recovered testSpoilersContainer from rootElement.'
          );
        } else {
          console.error(
            '[TestSpoilerUI ensureLogContainerReady] Could not find .test-spoilers-container in rootElement.'
          );
          this.rootElement.innerHTML =
            '<p>Error: UI container misconfigured.</p>'; // Fallback error message
          return;
        }
      } else {
        document.body.innerHTML =
          '<p>CRITICAL ERROR: TestSpoilerUI rootElement not found.</p>'; // Drastic fallback
        return;
      }
    }

    // Create controls container if it doesn't exist
    if (
      !this.controlsContainer ||
      !this.testSpoilersContainer.contains(this.controlsContainer)
    ) {
      this.controlsContainer = document.createElement('div');
      this.controlsContainer.id = 'spoiler-controls-container';
      this.controlsContainer.className = 'spoiler-controls-container'; // For potential specific styling
      // Prepend controls so log is at the bottom
      this.testSpoilersContainer.insertBefore(
        this.controlsContainer,
        this.testSpoilersContainer.firstChild
      );
    }

    // Create log container if it doesn't exist
    if (
      !this.logContainer ||
      !this.testSpoilersContainer.contains(this.logContainer)
    ) {
      this.logContainer = document.createElement('div');
      this.logContainer.id = 'spoiler-log-output';
      this.testSpoilersContainer.appendChild(this.logContainer); // Append log container at the end
    }
  }
}

// Add default export
export default TestSpoilerUI;
